"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[95996],{72089:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905)),o=n(61839);const r={title:"Plugin Implementation",sidebar_position:2,description:"Plugin Implementation\n"},l=void 0,s={unversionedId:"DeveloperManuals/PluginImplementation",id:"version-v0.15/DeveloperManuals/PluginImplementation",title:"Plugin Implementation",description:"Plugin Implementation\n",source:"@site/versioned_docs/version-v0.15/DeveloperManuals/PluginImplementation.md",sourceDirName:"DeveloperManuals",slug:"/DeveloperManuals/PluginImplementation",permalink:"/docs/v0.15/DeveloperManuals/PluginImplementation",draft:!1,editUrl:"https://github.com/apache/incubator-devlake-website/edit/main/versioned_docs/version-v0.15/DeveloperManuals/PluginImplementation.md",tags:[],version:"v0.15",sidebarPosition:2,frontMatter:{title:"Plugin Implementation",sidebar_position:2,description:"Plugin Implementation\n"},sidebar:"docsSidebar",previous:{title:"Developer Setup",permalink:"/docs/v0.15/DeveloperManuals/DeveloperSetup"},next:{title:"DB Migration",permalink:"/docs/v0.15/DeveloperManuals/DBMigration"}},p={},c=[{value:"What is a plugin?",id:"what-is-a-plugin",level:2},{value:"Types of plugins",id:"types-of-plugins",level:2},{value:"How do conventional plugins work?",id:"how-do-conventional-plugins-work",level:2},{value:"A step-by-step guide toward your first conventional plugin",id:"a-step-by-step-guide-toward-your-first-conventional-plugin",level:2},{value:"Step 1: Bootstrap the new plugin",id:"step-1-bootstrap-the-new-plugin",level:3},{value:"Step 2: Create a sub-task for data collection",id:"step-2-create-a-sub-task-for-data-collection",level:3},{value:"Step 2.1: Create a sub-task(Collector) for data collection",id:"step-21-create-a-sub-taskcollector-for-data-collection",level:4},{value:"Step 2.2: Create a sub-task(Extractor) to extract data from the raw layer",id:"step-22-create-a-sub-taskextractor-to-extract-data-from-the-raw-layer",level:4},{value:"Step 2.3: Convertor",id:"step-23-convertor",level:4},{value:"Step 2.4: Let&#39;s try it",id:"step-24-lets-try-it",level:4},{value:"Step 2.5: Implement the GetTablesInfo() method of the PluginModel interface",id:"step-25-implement-the-gettablesinfo-method-of-the-pluginmodel-interface",level:4},{value:"Final step: Submit the code as open source code",id:"final-step-submit-the-code-as-open-source-code",level:4},{value:"Done!",id:"done",level:3},{value:"How do Singer-spec plugins work?",id:"how-do-singer-spec-plugins-work",level:2},{value:"A step-by-step guide towards your first Singer-spec plugin",id:"a-step-by-step-guide-towards-your-first-singer-spec-plugin",level:2},{value:"Step 1: Singer tap setup",id:"step-1-singer-tap-setup",level:3},{value:"Step 2: Setting up Singer tap config",id:"step-2-setting-up-singer-tap-config",level:3},{value:"Step 3: Writing and generating the plugin code",id:"step-3-writing-and-generating-the-plugin-code",level:3},{value:"Done!",id:"done-1",level:3}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If your favorite DevOps tool is not yet supported by DevLake, don't worry. It's not difficult to implement a DevLake plugin. In this post, we'll go through the basics of DevLake plugins and build an example plugin from scratch together."),(0,i.kt)("h2",{id:"what-is-a-plugin"},"What is a plugin?"),(0,i.kt)("p",null,"A DevLake plugin is a shared library built with Go's ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin")," package that hooks up to DevLake core at run-time."),(0,i.kt)("p",null,"A plugin may extend DevLake's capability in three ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Integrating with new data sources"),(0,i.kt)("li",{parentName:"ol"},"Transforming/enriching existing data"),(0,i.kt)("li",{parentName:"ol"},"Exporting DevLake data to other data systems")),(0,i.kt)("h2",{id:"types-of-plugins"},"Types of plugins"),(0,i.kt)("p",null,"There are, as of now, support for two types of plugins:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Conventional plugins")),": These are the primary type of plugins used by Devlake, and require the developer to write the most amount of code starting from fetching (collecting) data from data sources to converting them into our normalized data models and storing them."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Singer-spec plugins")),": These plugins utilize ",(0,i.kt)("a",{parentName:"li",href:"https://www.singer.io/"},"Singer-taps")," to retrieve data from data-sources thereby eliminating the developer's burden of writing the collection logic. More on them ",(0,i.kt)("a",{parentName:"li",href:"#how-do-singer-spec-plugins-work"},"here"),".")),(0,i.kt)("h2",{id:"how-do-conventional-plugins-work"},"How do conventional plugins work?"),(0,i.kt)("p",null,"A plugin mainly consists of a collection of subtasks that can be executed by DevLake core. For data source plugins, a subtask may be collecting a single entity from the data source (e.g., issues from Jira). Besides the subtasks, there're hooks that a plugin can implement to customize its initialization, migration, and more. See below for a list of the most important interfaces:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_meta.go"},"PluginMeta")," contains the minimal interface that a plugin should implement, with only two functions ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Description() returns the description of a plugin"),(0,i.kt)("li",{parentName:"ul"},"RootPkgPath() returns the root package path of a plugin"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_init.go"},"PluginInit")," allows a plugin to customize its initialization"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_task.go"},"PluginTask")," enables a plugin to prepare data prior to subtask execution"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_api.go"},"PluginApi")," lets a plugin exposes some self-defined APIs"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_migration.go"},"PluginMigration")," is where a plugin manages its database migrations "),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_model.go"},"PluginModel")," allows other plugins to get the model information of all database tables of the current plugin through the GetTablesInfo() method. If you need to access Domain Layer Models, please visit ",(0,i.kt)("a",{parentName:"li",href:"https://devlake.apache.org/docs/DataModels/DevLakeDomainLayerSchema/"},"DomainLayerSchema")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_blueprint.go"},"PluginBlueprint")," is the foundation for Blueprint and Plugin to collaborate and generate a reasonable Pipeline Plan based on User Settings. For example, a user may declare that he/she wants to collect data from a GitHub Repo, which implies that not only the issues and PRs, but also the git-meta-data including commits history, branches, tags, etc. need to be collected. To do it and do it faster, leveraging ",(0,i.kt)("a",{parentName:"li",href:"../Plugins/gitextractor"},"GitExtractor")," is the best and recommended way. So, naturally, The GitHub/GitLab/BitBucket plugins will generate 2 concurrent ",(0,i.kt)("inlineCode",{parentName:"li"},"tasks"),", one for itself to collect issues and PRs, and one for ",(0,i.kt)("inlineCode",{parentName:"li"},"gitextractor")," to collect git-meta-data. For more detail, please read the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/core/plugin/plugin_blueprint.go"},"source file"))),(0,i.kt)("p",null,"The diagram below shows the control flow of executing a plugin:"),(0,i.kt)(o.G,{config:'{"theme":{"light":"neutral","dark":"forest"}}',chart:'flowchart TD;\n    subgraph S4[Step4 sub-task extractor running process];\n    direction LR;\n    D4[DevLake];\n    D4 -- "Step4.1 create a new\\n ApiExtractor\\n and execute it" --\x3e E["ExtractXXXMeta.\\nEntryPoint"];\n    E <-- "Step4.2 read from\\n raw table" --\x3e E2["RawDataSubTaskArgs\\n.Table"];\n    E -- "Step4.3 call with RawData" --\x3e ApiExtractor.Extract;\n    ApiExtractor.Extract -- "decode and return gorm models" --\x3e E\n    end\n    subgraph S3[Step3 sub-task collector running process]\n    direction LR\n    D3[DevLake]\n    D3 -- "Step3.1 create a new\\n ApiCollector\\n and execute it" --\x3e C["CollectXXXMeta.\\nEntryPoint"];\n    C <-- "Step3.2 create\\n raw table" --\x3e C2["RawDataSubTaskArgs\\n.RAW_BBB_TABLE"];\n    C <-- "Step3.3 build query\\n before sending requests" --\x3e ApiCollectorArgs.\\nQuery/UrlTemplate;\n    C <-. "Step3.4 send requests by ApiClient \\n and return HTTP response" .-> A1["HTTP APIs"];\n    C <-- "Step3.5 call and \\nreturn decoded data \\nfrom HTTP response" --\x3e ResponseParser;\n    end\n    subgraph S2[Step2 DevLake register custom plugin]\n    direction LR\n    D2[DevLake]\n    D2 <-- "Step2.1 function \\`Init\\` \\nneed to do init jobs" --\x3e plugin.Init;\n    D2 <-- "Step2.2 (Optional) call \\nand return migration scripts" --\x3e plugin.MigrationScripts;\n    D2 <-- "Step2.3 (Optional) call \\nand return taskCtx" --\x3e plugin.PrepareTaskData;\n    D2 <-- "Step2.4 call and \\nreturn subTasks for execting" --\x3e plugin.SubTaskContext;\n    end\n    subgraph S1[Step1 Run DevLake]\n    direction LR\n    main -- "Transfer of control \\nby \\`runner.DirectRun\\`" --\x3e D1[DevLake];\n    end\n    S1--\x3eS2--\x3eS3--\x3eS4',mdxType:"Mermaid"}),(0,i.kt)("p",null,"There's a lot of information in the diagram, but we don't expect you to digest it right away. You can simply use it as a reference when you go through the example below."),(0,i.kt)("h2",{id:"a-step-by-step-guide-toward-your-first-conventional-plugin"},"A step-by-step guide toward your first conventional plugin"),(0,i.kt)("p",null,"In this section, we will describe how to create a data collection plugin from scratch. The data to be collected is the information about all Committers and Contributors of the Apache project, in order to check whether they have signed the CLA. We are going to"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"request ",(0,i.kt)("inlineCode",{parentName:"li"},"https://people.apache.org/public/icla-info.json")," to get the Committers' information"),(0,i.kt)("li",{parentName:"ul"},"request the ",(0,i.kt)("inlineCode",{parentName:"li"},"mailing list")," to get the Contributors' information")),(0,i.kt)("p",null,"We will focus on demonstrating how to request and cache information about all Committers through the Apache API and extract structured data from it. The collection of Contributors will only be briefly described."),(0,i.kt)("h3",{id:"step-1-bootstrap-the-new-plugin"},"Step 1: Bootstrap the new plugin"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Please make sure you have DevLake up and running before proceeding."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"More info about plugin:\nGenerally, we need these folders in plugin folders: ",(0,i.kt)("inlineCode",{parentName:"p"},"api"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"models")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tasks"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"api")," interacts with ",(0,i.kt)("inlineCode",{parentName:"p"},"config-ui")," for test/get/save connection of data source"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre"},"  - connection [example](https://github.com/apache/incubator-devlake/blob/main/plugins/gitlab/api/connection.go)\n  - connection model [example](https://github.com/apache/incubator-devlake/blob/main/plugins/gitlab/models/connection.go)\n")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"models")," stores all ",(0,i.kt)("inlineCode",{parentName:"p"},"data entities")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"data migration scripts"),". "),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre"},"  - entity \n  - data migrations [template](https://github.com/apache/incubator-devlake/tree/main/generator/template/migrationscripts)\n")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"tasks")," contains all of our ",(0,i.kt)("inlineCode",{parentName:"p"},"sub tasks")," for a plugin"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre"},"  - task data [template](https://github.com/apache/incubator-devlake/blob/main/generator/template/plugin/tasks/task_data.go-template)\n  - api client [template](https://github.com/apache/incubator-devlake/blob/main/generator/template/plugin/tasks/task_data_with_api_client.go-template)\n"))),(0,i.kt)("p",null,"Don't worry if you cannot figure out what these concepts mean immediately. We'll explain them one by one later."),(0,i.kt)("p",null,"Apache DevLake provides a generator to create a plugin conveniently. Let's scaffold our new plugin by running ",(0,i.kt)("inlineCode",{parentName:"p"},"go run generator/main.go create-plugin icla"),", which would ask for ",(0,i.kt)("inlineCode",{parentName:"p"},"with_api_client")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Endpoint"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"with_api_client")," is used for choosing if we need to request HTTP APIs by api_client. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Endpoint")," use in which site we will request, in our case, it should be ",(0,i.kt)("inlineCode",{parentName:"li"},"https://people.apache.org/"),".")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/itzlFg7.png",alt:null})),(0,i.kt)("p",null,"Now we have three files in our plugin. ",(0,i.kt)("inlineCode",{parentName:"p"},"api_client.go")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"task_data.go")," are in the subfolder ",(0,i.kt)("inlineCode",{parentName:"p"},"tasks/"),".\n",(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/zon5waf.png",alt:"plugin files"})),(0,i.kt)("p",null,"Have a try to run this plugin by function ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin_main.go"),". When you see results like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$go run plugins/icla/plugin_main.go\n[2022-06-02 18:07:30]  INFO failed to create dir logs: mkdir logs: file exists\npress `c` to send cancel signal\n[2022-06-02 18:07:30]  INFO  [icla] start plugin\ninvalid ICLA_TOKEN, but ignore this error now\n[2022-06-02 18:07:30]  INFO  [icla] scheduler for api https://people.apache.org/ worker: 25, request: 18000, duration: 1h0m0s\n[2022-06-02 18:07:30]  INFO  [icla] total step: 0\n")),(0,i.kt)("p",null,"It works! Plugin 'icla' is defined and initiated. This plugin ONLY contains ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin_main.go")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"task_data.go"),", which is the simplest form of a plugin in Apache DevLake. In the next step, we'll show you how to request HTTP APIs by ",(0,i.kt)("inlineCode",{parentName:"p"},"api_client.go"),"."),(0,i.kt)("h3",{id:"step-2-create-a-sub-task-for-data-collection"},"Step 2: Create a sub-task for data collection"),(0,i.kt)("p",null,"Before we start, it is helpful to know how a collection task is executed: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"First, Apache DevLake would call ",(0,i.kt)("inlineCode",{parentName:"li"},"plugin_main.PrepareTaskData()")," to prepare needed data before any sub-tasks. We need to create an API client here."),(0,i.kt)("li",{parentName:"ol"},"Then Apache DevLake will call the sub-tasks returned by ",(0,i.kt)("inlineCode",{parentName:"li"},"plugin_main.SubTaskMetas()"),". Sub-task is an independent task to do some job, like requesting API, processing data, etc.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Each sub-task must be defined as a SubTaskMeta, and implement SubTaskEntryPoint of SubTaskMeta. SubTaskEntryPoint is defined as "),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type SubTaskEntryPoint func(c SubTaskContext) error\n")),(0,i.kt)("p",{parentName:"blockquote"},"More info at: ",(0,i.kt)("a",{parentName:"p",href:"https://devlake.apache.org/blog/how-DevLake-is-up-and-running/"},"https://devlake.apache.org/blog/how-DevLake-is-up-and-running/"))),(0,i.kt)("h4",{id:"step-21-create-a-sub-taskcollector-for-data-collection"},"Step 2.1: Create a sub-task(Collector) for data collection"),(0,i.kt)("p",null,"Let's run ",(0,i.kt)("inlineCode",{parentName:"p"},"go run generator/main.go create-collector icla committer")," and confirm it. This sub-task is activated by registering in ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin_main.go/SubTaskMetas")," automatically."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/tkDuofi.png",alt:null})),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Collector will collect data from HTTP or other data sources, and save the data into the raw layer. "),(0,i.kt)("li",{parentName:"ul"},"Inside the func ",(0,i.kt)("inlineCode",{parentName:"li"},"SubTaskEntryPoint")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"Collector"),", we use ",(0,i.kt)("inlineCode",{parentName:"li"},"helper.NewApiCollector")," to create an object of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/apache/incubator-devlake/blob/main/backend/generator/template/plugin/tasks/api_collector.go-template"},"ApiCollector"),", then call ",(0,i.kt)("inlineCode",{parentName:"li"},"execute()")," to do the job. "))),(0,i.kt)("p",null,"Now you can notice ",(0,i.kt)("inlineCode",{parentName:"p"},"data.ApiClient")," is initiated in ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin_main.go/PrepareTaskData.ApiClient"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"PrepareTaskData")," creates a new ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiClient"),", which is a tool Apache DevLake suggests to request data from HTTP Apis. This tool support some valuable features for HttpApi, like rateLimit, proxy and retry. Of course, if you like, you may use the lib ",(0,i.kt)("inlineCode",{parentName:"p"},"http")," instead, but it will be more tedious."),(0,i.kt)("p",null,"Let's move forward to use it."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"To collect data from ",(0,i.kt)("inlineCode",{parentName:"li"},"https://people.apache.org/public/icla-info.json"),",\nwe have filled ",(0,i.kt)("inlineCode",{parentName:"li"},"https://people.apache.org/")," into ",(0,i.kt)("inlineCode",{parentName:"li"},"tasks/api_client.go/ENDPOINT")," in Step 1.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/q8Zltnl.png",alt:null})),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Fill ",(0,i.kt)("inlineCode",{parentName:"li"},"public/icla-info.json")," into ",(0,i.kt)("inlineCode",{parentName:"li"},"UrlTemplate"),", delete the unnecessary iterator and add ",(0,i.kt)("inlineCode",{parentName:"li"},'println("receive data:", res)')," in ",(0,i.kt)("inlineCode",{parentName:"li"},"ResponseParser")," to see if collection was successful.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/ToLMclH.png",alt:null})),(0,i.kt)("p",null,"Ok, now the collector sub-task has been added to the plugin, and we can kick it off by running ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," again. If everything goes smoothly, the output should look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"[2022-06-06 12:24:52]  INFO  [icla] start plugin\ninvalid ICLA_TOKEN, but ignore this error now\n[2022-06-06 12:24:52]  INFO  [icla] scheduler for api https://people.apache.org/ worker: 25, request: 18000, duration: 1h0m0s\n[2022-06-06 12:24:52]  INFO  [icla] total step: 1\n[2022-06-06 12:24:52]  INFO  [icla] executing subtask CollectCommitter\n[2022-06-06 12:24:52]  INFO  [icla] [CollectCommitter] start api collection\nreceive data: 0x140005763f0\n[2022-06-06 12:24:55]  INFO  [icla] [CollectCommitter] finished records: 1\n[2022-06-06 12:24:55]  INFO  [icla] [CollectCommitter] end api collection\n[2022-06-06 12:24:55]  INFO  [icla] finished step: 1 / 1\n")),(0,i.kt)("p",null,"Great! Now we can see data pulled from the server without any problem. The last step is to decode the response body in ",(0,i.kt)("inlineCode",{parentName:"p"},"ResponseParser")," and return it to the framework, so it can be stored in the database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'ResponseParser: func(res *http.Response) ([]json.RawMessage, error) {\n    body := &struct {\n        LastUpdated string          `json:"last_updated"`\n        Committers  json.RawMessage `json:"committers"`\n    }{}\n    err := helper.UnmarshalResponse(res, body)\n    if err != nil {\n        return nil, err\n    }\n    println("receive data:", len(body.Committers))\n    return []json.RawMessage{body.Committers}, nil\n},\n\n')),(0,i.kt)("p",null,"Ok, run the function ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," once again, then it turned out like this, and we should be able to see some records show up in the table ",(0,i.kt)("inlineCode",{parentName:"p"},"_raw_icla_committer"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"\u2026\u2026\nreceive data: 272956 /* <- the number means 272956 models received */\n[2022-06-06 13:46:57]  INFO  [icla] [CollectCommitter] finished records: 1\n[2022-06-06 13:46:57]  INFO  [icla] [CollectCommitter] end api collection\n[2022-06-06 13:46:57]  INFO  [icla] finished step: 1 / 1\n")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/aVYNMRr.png",alt:null})),(0,i.kt)("h4",{id:"step-22-create-a-sub-taskextractor-to-extract-data-from-the-raw-layer"},"Step 2.2: Create a sub-task(Extractor) to extract data from the raw layer"),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Extractor will extract data from raw layer and save it into tool db table."),(0,i.kt)("li",{parentName:"ul"},"Except for some pre-processing, the main flow is similar to the collector."))),(0,i.kt)("p",null,"We have already collected data from HTTP API and saved them into the DB table ",(0,i.kt)("inlineCode",{parentName:"p"},"_raw_XXXX"),". In this step, we will extract the names of committers from the raw data. As you may infer from the name, raw tables are temporary and not easy to use directly."),(0,i.kt)("p",null,"Now Apache DevLake suggests saving data by ",(0,i.kt)("a",{parentName:"p",href:"https://gorm.io/docs/index.html"},"gorm"),", so we will create a model by gorm and add it into ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin_main.go/AutoMigrate()"),"."),(0,i.kt)("p",null,"plugins/icla/models/committer.go"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package models\n\nimport (\n    "github.com/apache/incubator-devlake/models/common"\n)\n\ntype IclaCommitter struct {\n    UserName     string `gorm:"primaryKey;type:varchar(255)"`\n    Name         string `gorm:"primaryKey;type:varchar(255)"`\n    common.NoPKModel\n}\n\nfunc (IclaCommitter) TableName() string {\n    return "_tool_icla_committer"\n}\n')),(0,i.kt)("p",null,"plugins/icla/plugin_main.go\n",(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/4f0zJty.png",alt:null})),(0,i.kt)("p",null,"Ok, run the plugin, and table ",(0,i.kt)("inlineCode",{parentName:"p"},"_tool_icla_committer")," will be created automatically just like the snapshot below:\n",(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/7Z324IX.png",alt:null})),(0,i.kt)("p",null,"Next, let's run ",(0,i.kt)("inlineCode",{parentName:"p"},"go run generator/main.go create-extractor icla committer")," and type in what the command prompt asks for to create a new sub-task."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/UyDP9Um.png",alt:null})),(0,i.kt)("p",null,"Let's look at the function ",(0,i.kt)("inlineCode",{parentName:"p"},"extract")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"committer_extractor.go")," created just now, and the code that needs to be written here. It's obvious that ",(0,i.kt)("inlineCode",{parentName:"p"},"resData.data")," is the raw data, so we could json-decode each row add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"IclaCommitter")," for each and save them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"Extract: func(resData *helper.RawData) ([]interface{}, error) {\n    names := &map[string]string{}\n    err := json.Unmarshal(resData.Data, names)\n    if err != nil {\n        return nil, err\n    }\n    extractedModels := make([]interface{}, 0)\n    for userName, name := range *names {\n        extractedModels = append(extractedModels, &models.IclaCommitter{\n            UserName: userName,\n            Name:     name,\n        })fco\n    }\n    return extractedModels, nil\n},\n")),(0,i.kt)("p",null,"Ok, run it then we get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[2022-06-06 15:39:40]  INFO  [icla] start plugin\ninvalid ICLA_TOKEN, but ignore this error now\n[2022-06-06 15:39:40]  INFO  [icla] scheduler for api https://people.apache.org/ worker: 25, request: 18000, duration: 1h0m0s\n[2022-06-06 15:39:40]  INFO  [icla] total step: 2\n[2022-06-06 15:39:40]  INFO  [icla] executing subtask CollectCommitter\n[2022-06-06 15:39:40]  INFO  [icla] [CollectCommitter] start api collection\nreceive data: 272956\n[2022-06-06 15:39:44]  INFO  [icla] [CollectCommitter] finished records: 1\n[2022-06-06 15:39:44]  INFO  [icla] [CollectCommitter] end api collection\n[2022-06-06 15:39:44]  INFO  [icla] finished step: 1 / 2\n[2022-06-06 15:39:44]  INFO  [icla] executing subtask ExtractCommitter\n[2022-06-06 15:39:46]  INFO  [icla] [ExtractCommitter] finished records: 1\n[2022-06-06 15:39:46]  INFO  [icla] finished step: 2 / 2\n")),(0,i.kt)("p",null,"Now committer data have been saved in _tool_icla_committer.\n",(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/6svX0N2.png",alt:null})),(0,i.kt)("h4",{id:"step-23-convertor"},"Step 2.3: Convertor"),(0,i.kt)("p",null,"Notes: The goal of Converters is to create a vendor-agnostic model out of the vendor-dependent ones created by the Extractors.\nThey are not necessary to have per se, but we encourage it because converters and the domain layer will significantly help with building dashboards. More info about the domain layer ",(0,i.kt)("a",{parentName:"p",href:"https://devlake.apache.org/docs/DataModels/DevLakeDomainLayerSchema/"},"here"),"."),(0,i.kt)("p",null,"In short:"),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Convertor will convert data from the tool layer and save it into the domain layer."),(0,i.kt)("li",{parentName:"ul"},"We use ",(0,i.kt)("inlineCode",{parentName:"li"},"helper.NewDataConverter")," to create an object of DataConvertor, then call ",(0,i.kt)("inlineCode",{parentName:"li"},"execute()"),". "))),(0,i.kt)("h4",{id:"step-24-lets-try-it"},"Step 2.4: Let's try it"),(0,i.kt)("p",null,"Sometimes OpenApi will be protected by token or other auth types, and we need to log in to gain a token to visit it. For example, only after logging in ",(0,i.kt)("inlineCode",{parentName:"p"},"private@apahce.com")," could we gather the data about contributors signing ICLA. Here we briefly introduce how to authorize DevLake to collect data."),(0,i.kt)("p",null,"Let's look at ",(0,i.kt)("inlineCode",{parentName:"p"},"api_client.go"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"NewIclaApiClient")," load config ",(0,i.kt)("inlineCode",{parentName:"p"},"ICLA_TOKEN")," by ",(0,i.kt)("inlineCode",{parentName:"p"},".env"),", so we can add ",(0,i.kt)("inlineCode",{parentName:"p"},"ICLA_TOKEN=XXXXXX")," in ",(0,i.kt)("inlineCode",{parentName:"p"},".env")," and use it in ",(0,i.kt)("inlineCode",{parentName:"p"},"apiClient.SetHeaders()")," to mock the login status. Code as below:\n",(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/dPxooAx.png",alt:null})),(0,i.kt)("p",null,"Of course, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"username/password")," to get a token after login mockery. Just try and adjust according to the actual situation."),(0,i.kt)("p",null,"Look for more related details at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-devlake"},"https://github.com/apache/incubator-devlake")),(0,i.kt)("h4",{id:"step-25-implement-the-gettablesinfo-method-of-the-pluginmodel-interface"},"Step 2.5: Implement the GetTablesInfo() method of the PluginModel interface"),(0,i.kt)("p",null,"As shown in the following gitlab plugin example,\nadd all models that need to be accessed by external plugins to the return value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"var _ core.PluginModel = (*Gitlab)(nil)\n\nfunc (plugin Gitlab) GetTablesInfo() []core.Tabler {\n    return []core.Tabler{\n        &models.GitlabConnection{},\n        &models.GitlabAccount{},\n        &models.GitlabCommit{},\n        &models.GitlabIssue{},\n        &models.GitlabIssueLabel{},\n        &models.GitlabJob{},\n        &models.GitlabMergeRequest{},\n        &models.GitlabMrComment{},\n        &models.GitlabMrCommit{},\n        &models.GitlabMrLabel{},\n        &models.GitlabMrNote{},\n        &models.GitlabPipeline{},\n        &models.GitlabProject{},\n        &models.GitlabProjectCommit{},\n        &models.GitlabReviewer{},\n        &models.GitlabTag{},\n    }\n}\n")),(0,i.kt)("p",null,"You can use it as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"if pm, ok := plugin.(core.PluginModel); ok {\n    tables := pm.GetTablesInfo()\n    for _, table := range tables {\n        // do something\n    }\n}\n\n")),(0,i.kt)("h4",{id:"final-step-submit-the-code-as-open-source-code"},"Final step: Submit the code as open source code"),(0,i.kt)("p",null,"We encourage ideas and contributions ~ Let's use migration scripts, domain layers and other discussed concepts to write normative and platform-neutral code. More info at ",(0,i.kt)("a",{parentName:"p",href:"https://devlake.apache.org/docs/DataModels/DevLakeDomainLayerSchema"},"here")," or contact us for ebullient help."),(0,i.kt)("h3",{id:"done"},"Done!"),(0,i.kt)("p",null,"Congratulations! The first plugin has been created! \ud83c\udf96 "),(0,i.kt)("h2",{id:"how-do-singer-spec-plugins-work"},"How do Singer-spec plugins work?"),(0,i.kt)("p",null,"These plugins share a lot in common with ",(0,i.kt)("a",{parentName:"p",href:"#how-do-conventional-plugins-work"},"conventional plugins"),", except the collector stage uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"Tap")," abstraction. You will additionally need to configure JSON files for the ","[singer-tap]"," that\nyou are intending to use. These configuration files will tell the tap what APIs are available and what schema of data is expected to be returned by each of them."),(0,i.kt)("h2",{id:"a-step-by-step-guide-towards-your-first-singer-spec-plugin"},"A step-by-step guide towards your first Singer-spec plugin"),(0,i.kt)("p",null,"For this demo, we will create a simple GitHub plugin using the Singer-spec. Make sure you have familiarized yourself, at a high-level at least, with the concepts of ",(0,i.kt)("a",{parentName:"p",href:"#a-step-by-step-guide-towards-your-first-conventional-plugin"},"conventional plugins")," before proceeding."),(0,i.kt)("h3",{id:"step-1-singer-tap-setup"},"Step 1: Singer tap setup"),(0,i.kt)("p",null,"Consult the documentation of the specific tap before getting started. Usually the steps go like this:"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"1.1"),". Make sure you have Python 3+ with ",(0,i.kt)("inlineCode",{parentName:"p"},"pip")," installed."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"1.2"),". Add the python module for the singer tap to the ",(0,i.kt)("inlineCode",{parentName:"p"},"requirements.txt")," in the root Devlake directory."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"1.3"),". Run ",(0,i.kt)("inlineCode",{parentName:"p"},"make dep")," to get the tap as well other dependencies, if missing, installed."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"1.4"),". You now have the tap binary installed and available on your $PATH."),(0,i.kt)("h3",{id:"step-2-setting-up-singer-tap-config"},"Step 2: Setting up Singer tap config"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"2.1"),". You will need to determine the structure of the ",(0,i.kt)("inlineCode",{parentName:"p"},"config.json")," required to communicate with the tap. This should be in the documentation of the tap. This file will contain the config\nneeded to have the tap make the API calls (e.g. authentication info, endpoint, etc)"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"2.2"),". In some temp directory, create such a ",(0,i.kt)("inlineCode",{parentName:"p"},"config.json")," file, and then run ",(0,i.kt)("inlineCode",{parentName:"p"},"<tap-name> -c config.json --discover > properties.json"),". This will create a ",(0,i.kt)("inlineCode",{parentName:"p"},"properties.json"),' file that contains all the\ndiscovered "streams" of that tap. Each stream corresponds to a unique API call, and contains multiple fields including the JSON schema of the expected response for that stream.'),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"2.3"),". Place this ",(0,i.kt)("inlineCode",{parentName:"p"},"properties.json")," file under ",(0,i.kt)("inlineCode",{parentName:"p"},"config/singer")," and name it to something more specific, for instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"github.json"),", following our example."),(0,i.kt)("h3",{id:"step-3-writing-and-generating-the-plugin-code"},"Step 3: Writing and generating the plugin code"),(0,i.kt)("p",null,"As of now, the generator does not support scaffolding code for these plugins. As a workaround, use the generator to create a regular REST plugin and make the following modifications. We'll assume\nthe plugin created for this example is called ",(0,i.kt)("inlineCode",{parentName:"p"},"github_singer"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.1"),". Under ",(0,i.kt)("inlineCode",{parentName:"p"},"github_singer/models")," create a ",(0,i.kt)("inlineCode",{parentName:"p"},"config.go")," file that captures the structure of the ",(0,i.kt)("inlineCode",{parentName:"p"},"config.json")," you used earlier. For this example, it'd look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// GithubConfig models corresponds to docs here https://github.com/singer-io/tap-github\ntype GithubConfig struct {\n    AccessToken    string    `json:"access_token"`\n    Repository     string    `json:"repository"`\n    StartDate      time.Time `json:"start_date"`\n    RequestTimeout int       `json:"request_timeout"`\n    BaseUrl        string    `json:"base_url"`\n}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.2"),". Modify ",(0,i.kt)("inlineCode",{parentName:"p"},"github_singer/tasks/task_data.go")," to have the options and task-data appropriate for the subtasks. It is important that the ",(0,i.kt)("inlineCode",{parentName:"p"},"TaskData")," struct contains a reference to the config struct,\nthe connection-ID, and a function pointer that returns a Tap client. In our example, we could have:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type GithubSingerOptions struct {\n    ConnectionId uint64   `json:"connectionId"`\n    Owner        string   `json:"owner"`\n    Tasks        []string `json:"tasks,omitempty"`\n}\n\ntype GithubSingerTaskData struct {\n    Options   *GithubSingerOptions `json:"-"`\n    TapConfig *models.GithubConfig\n    TapClient *tap.SingerTap\n}\n\ntype GithubApiParams struct {\n    Repo         string\n    Owner        string\n    ConnectionId uint64\n}\n\nfunc DecodeAndValidateTaskOptions(options map[string]interface{}) (*GithubSingerOptions, errors.Error) {\n    var op GithubSingerOptions\n    if err := helper.Decode(options, &op, nil); err != nil {\n        return nil, err\n    }\n    if op.ConnectionId == 0 {\n        return nil, errors.Default.New("connectionId is invalid")\n    }\n    return &op, nil\n}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.3"),". Modify ",(0,i.kt)("inlineCode",{parentName:"p"},"github_singer/impl/impl.go")," so that ",(0,i.kt)("inlineCode",{parentName:"p"},"PrepareTaskData")," creates the TaskData struct from the Options. In our case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func (plugin GithubSinger) PrepareTaskData(taskCtx core.TaskContext, options map[string]interface{}) (interface{}, errors.Error) {\n    op, err := tasks.DecodeAndValidateTaskOptions(options)\n    if err != nil {\n        return nil, err\n    }\n    connectionHelper := helper.NewConnectionHelper(\n        taskCtx,\n        nil,\n    )\n    connection := &models.GithubConnection{}\n    err = connectionHelper.FirstById(connection, op.ConnectionId)\n    if err != nil {\n        return nil, errors.Default.Wrap(err, "unable to get GithubSinger connection by the given connection ID")\n    }\n    endpoint := strings.TrimSuffix(connection.Endpoint, "/")\n    tapClient, err := tap.NewSingerTap(&tap.SingerTapConfig{\n        TapExecutable:        "tap-github",\n        StreamPropertiesFile: "github_keon.json",\n        IsLegacy:             true,\n    })\n    if err != nil {\n        return nil, err\n    }\n    return &tasks.GithubSingerTaskData{\n        Options:   op,\n        TapClient: tapClient,\n        TapConfig: &models.GithubConfig{\n            AccessToken:    connection.Token,\n            Repository:     options["repo"].(string),\n            StartDate:      options["start_date"].(time.Time),\n            RequestTimeout: 300,\n            BaseUrl:        endpoint,\n        },\n    }, nil\n}\n')),(0,i.kt)("p",null,"Note that the TapExecutable variable here was set to ",(0,i.kt)("inlineCode",{parentName:"p"},'"tap-github"'),", which is the name of the python executable for the tap.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamPropertiesFile")," is the name of the properties file of interest, and is expected to reside in the directory referenced by the environment variable ",(0,i.kt)("inlineCode",{parentName:"p"},'"TAP_PROPERTIES_DIR"'),". This directory is\nexpected to be shared for all these JSON files. In our example, this directory is ",(0,i.kt)("inlineCode",{parentName:"p"},"<devlake-root>/config/tap"),".\nFurthermore, observe how we created the ",(0,i.kt)("inlineCode",{parentName:"p"},"GithubConfig"),' object: The raw options needed two variables "repo" and "start_date", and the remaining fields were derivable from the connection instance.\nThese details will vary from tap to tap, but the gist will be the same.'),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.4"),". Since this is a Singer plugin, the collector will have to be modified to look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package tasks\n\nimport (\n    "github.com/apache/incubator-devlake/errors"\n    "github.com/apache/incubator-devlake/helpers/pluginhelper/tap"\n    "github.com/apache/incubator-devlake/plugins/core"\n    "github.com/apache/incubator-devlake/plugins/helper"\n)\n\nvar _ core.SubTaskEntryPoint = CollectIssues\n\nfunc CollectIssues(taskCtx core.SubTaskContext) errors.Error {\n    data := taskCtx.GetData().(*GithubSingerTaskData)\n    collector, err := tap.NewTapCollector(\n        &tap.CollectorArgs[tap.SingerTapStream]{\n            RawDataSubTaskArgs: helper.RawDataSubTaskArgs{\n                Ctx:   taskCtx,\n                Table: "singer_github_issue",\n                Params: GithubApiParams{\n                    Repo:         data.TapConfig.Repository,\n                    Owner:        data.Options.Owner,\n                    ConnectionId: data.Options.ConnectionId,\n                },\n            },\n            TapClient:    data.TapClient,\n            TapConfig:    data.TapConfig,\n            ConnectionId: data.Options.ConnectionId,\n            StreamName:   "issues",\n        },\n    )\n    if err != nil {\n        return err\n    }\n    return collector.Execute()\n}\n\nvar CollectIssuesMeta = core.SubTaskMeta{\n    Name:             "CollectIssues",\n    EntryPoint:       CollectIssues,\n    EnabledByDefault: true,\n    Description:      "Collect singer-tap Github issues",\n}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.5"),'. Generate the data models corresponding to the JSON schemas of the streams of interest. These make life easy at the Extractor stage as we will not need to write "Response" structs by hand.\nWe have a custom script that gets this job done. See ',(0,i.kt)("inlineCode",{parentName:"p"},"scripts/singer-model-generator.sh"),'. For our example, if we care about\nwriting an extractor for GitHub Issues, we\'ll have to refer to the properties.json (or github.json) file to identify the stream name associated with it. In this case, it is called "issues". Next, we run the following\ncommand: ',(0,i.kt)("inlineCode",{parentName:"p"},'sh ./scripts/singer-model-generator.sh "./config/tap/github.json" "./plugins/github_singer" "issues"'),". (Make sure the script has execution permissions - ",(0,i.kt)("inlineCode",{parentName:"p"},"sh chmod +x ./scripts/singer-model-generator.sh"),".\nFor the sake of convenience, the script supports an ",(0,i.kt)("inlineCode",{parentName:"p"},"--all")," flag in place of the stream. This will generate source files for all stream. Also, see the ",(0,i.kt)("inlineCode",{parentName:"p"},"tap-models")," target in the Makefile for references, and add your invocations\nthere."),(0,i.kt)("p",null,"This will generate Go (raw) data models and place them under ",(0,i.kt)("inlineCode",{parentName:"p"},"github_singer/models/generated"),". Do not modify these files manually."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.5.1"),". Note: Occasionally, the tap properties will not expose all the supported fields in the JSON schema - you can go and manually add them there in the JSON file. Additionally, you might run into type-problems (for instance IDs coming back as strings but declared as integers). In general, these would be rare scenarios, and technically bugs for the tap that you would experimentally run into while testing.\nEither way, if you need to modify these data-types, do it in the JSON file."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"3.6"),". The remaining steps are just like what you would do for conventional plugins (e.g. the REST APIs, migrations, etc). Again, the generated source files from step ",(0,i.kt)("em",{parentName:"p"},"3.5")," can be used in the\nextractor for row-data deserialization."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Final step:")," ",(0,i.kt)("a",{parentName:"p",href:"#final-step-submit-the-code-as-open-source-code"},"Submit the code as open source code")),(0,i.kt)("h3",{id:"done-1"},"Done!"),(0,i.kt)("p",null,"Congratulations! You have created a Singer-spec plugin!"))}d.isMDXComponent=!0}}]);